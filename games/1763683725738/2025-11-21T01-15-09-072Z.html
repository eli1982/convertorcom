
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Mystic Forest Farm</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { margin: 0; background-color: #000; color: #fff; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
            font-size: 1.5rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000000;
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        #instructions {
            width: 50%;
            padding: 20px;
            background: rgba(26, 26, 46, 0.8);
            border: 2px solid #fff;
            border-radius: 10px;
        }
        h1 { color: #FFFACD; }
        p { font-size: 1.2rem; }
        .win-message {
            display: none;
            font-size: 5rem;
            color: #00ff00;
            text-shadow: 3px 3px 6px #000;
        }
    </style>
</head>
<body>
    <div id="info">
        <div id="score">Spirits Saved: 0/10</div>
        <div id="win" class="win-message">FOREST RESTORED</div>
    </div>

    <div id="blocker">
        <div id="instructions">
            <h1>Mystic Forest Farm</h1>
            <p>The forest is corrupted. Use your Flaming Sword to cleanse the wandering spirits.</p>
            <p><strong>Controls:</strong><br>
            WASD: Move<br>
            SPACE: Jump<br>
            MOUSE: Look<br>
            LEFT CLICK: Swing Sword</p>
            <p>Click to Begin</p>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { Reflector } from 'three/addons/objects/Reflector.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Core Setup ---
        let camera, scene, renderer, controls, composer;
        let clock = new THREE.Clock();

        // --- Physics & Player ---
        const player = {
            height: 2.0,
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            onGround: false,
            speed: 40.0,
            jumpSpeed: 10.0,
            gravity: 25.0
        };
        const moveForward = { value: false }, moveBackward = { value: false }, moveLeft = { value: false }, moveRight = { value: false };

        // --- Game State ---
        const TOTAL_SPIRITS = 15;
        const SPIRITS_TO_WIN = 10;
        let savedSpirits = 0;
        const spirits = [];
        const projectiles = [];
        const wildlife = [];

        // --- Atmosphere ---
        const atmosphere = {
            start: { sky: new THREE.Color(0x1a1a2e), fog: new THREE.Color(0xffffff), sun: new THREE.Color(0xffffff) },
            end: { sky: new THREE.Color(0x87CEEB), fog: new THREE.Color(0xFFFFFF), sun: new THREE.Color(0xFFFACD) },
            fogNear: { start: 27, end: 200 },
            fogFar: { start: 300, end: 500 },
            sunIntensity: { start: 0.5, end: 1.5 },
            bloomStrength: { start: 0.6, end: 0.0 }
        };
        let directionalLight, ambientLight;
        let bloomPass;
        let rain, lightningFlash;
        let time = 0;

        // --- Weapon ---
        let sword, weaponHolder, swordFlames;
        let weaponCooldown = 0.5;
        let lastFireTime = -1; // Ready to fire immediately
        let isSwinging = false;
        let swingProgress = 0;


        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(atmosphere.start.sky);
            // scene.fog = new THREE.Fog(atmosphere.start.fog, atmosphere.fogNear.start, atmosphere.fogFar.start); // Fog disabled per instructions

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = player.height;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(scene.background);
            document.body.appendChild(renderer.domElement);

            // Post-processing
            const renderPass = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = atmosphere.bloomStrength.start;
            bloomPass.radius = 0;
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            // Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(atmosphere.start.sun, atmosphere.sunIntensity.start);
            directionalLight.position.set(50, 50, 50);
            scene.add(directionalLight);

            // Pointer Lock Controls
            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');
            controls = new PointerLockControls(camera, document.body);
            instructions.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => {
                blocker.style.display = 'none';
                instructions.style.display = 'none';
            });
            controls.addEventListener('unlock', () => {
                blocker.style.display = 'flex';
                instructions.style.display = 'block';
            });
            scene.add(controls.getObject());

            // Controls Listeners
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward.value = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft.value = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward.value = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight.value = true; break;
                    case 'Space': if (player.onGround) player.velocity.y += player.jumpSpeed; break;
                }
            });
            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward.value = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft.value = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward.value = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight.value = false; break;
                }
            });
            document.addEventListener('mousedown', (e) => {
                if (controls.isLocked && e.button === 0) {
                    const now = clock.getElapsedTime();
                    if (now - lastFireTime > weaponCooldown) {
                        lastFireTime = now;
                        fireProjectile();
                        isSwinging = true;
                        swingProgress = 0;
                    }
                }
            });

            createEnvironment();
            createWeapon();
            spawnSpirits();
            spawnWildlife();
            createWeather();

            window.addEventListener('resize', onWindowResize);
        }

        // --- Object Creation ---

        function createNoiseTexture(width, height, color1, color2) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');
            const imageData = context.createImageData(width, height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const value = Math.random();
                const color = value > 0.5 ? color1 : color2;
                data[i] = color.r * 255;
                data[i + 1] = color.g * 255;
                data[i + 2] = color.b * 255;
                data[i + 3] = 255;
            }
            context.putImageData(imageData, 0, 0);
            return new THREE.CanvasTexture(canvas);
        }

        function createEnvironment() {
            // Ground
            const groundTexture = createNoiseTexture(64, 64, new THREE.Color(0x223d1e), new THREE.Color(0x3e6b37));
            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(32, 32);
            const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture });
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(80, 80), groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.name = 'ground';
            scene.add(ground);

            // Water
            const waterGeometry = new THREE.PlaneGeometry(10, 80);
            const water = new Reflector(waterGeometry, {
                clipBias: 0.003,
                textureWidth: window.innerWidth * window.devicePixelRatio,
                textureHeight: window.innerHeight * window.devicePixelRatio,
                color: 0x777777,
            });
            water.rotation.x = -Math.PI / 2;
            water.position.y = 0.05;
            scene.add(water);

            // Structures (based on image)
            const stoneMat = new THREE.MeshLambertMaterial({ color: 0xaaaaaa, map: createNoiseTexture(16,16, new THREE.Color(0xaaaaaa), new THREE.Color(0xbbbbbb)) });
            const roofMat = new THREE.MeshLambertMaterial({ color: 0x6b4f35, map: createNoiseTexture(16,16, new THREE.Color(0x6b4f35), new THREE.Color(0x5a422a)) });
            const whiteMat = new THREE.MeshLambertMaterial({ color: 0xe5e5e5 });

            // Church-like building
            const church = new THREE.Group();
            const churchBody = new THREE.Mesh(new THREE.BoxGeometry(8, 7, 12), whiteMat);
            churchBody.position.y = 3.5;
            const churchRoof = new THREE.Mesh(new THREE.BoxGeometry(9, 0.5, 13), roofMat);
            churchRoof.position.y = 7;
            const towerBase = new THREE.Mesh(new THREE.BoxGeometry(3, 10, 3), whiteMat);
            towerBase.position.set(0, 5, -5);
            const steeple = new THREE.Mesh(new THREE.ConeGeometry(2, 4, 4), roofMat);
            steeple.position.set(0, 12, -5);
            steeple.rotation.y = Math.PI / 4;
            church.add(churchBody, churchRoof, towerBase, steeple);
            church.position.set(20, 0, 10);
            scene.add(church);

            // Small shed
            const shed = new THREE.Group();
            const shedBody = new THREE.Mesh(new THREE.BoxGeometry(6, 4, 5), stoneMat);
            shedBody.position.y = 2;
            const shedRoofGeo = new THREE.BufferGeometry();
            const vertices = new Float32Array([ -3.5,4,2.5,  3.5,4,2.5,  3.5,5.5,0, -3.5,5.5,0, -3.5,4,-2.5, 3.5,4,-2.5 ]);
            const indices = [ 0,1,2, 0,2,3, 1,5,2, 4,0,3, 4,3,2, 4,2,5 ];
            shedRoofGeo.setIndex(indices);
            shedRoofGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            shedRoofGeo.computeVertexNormals();
            const shedRoof = new THREE.Mesh(shedRoofGeo, roofMat);
            shed.add(shedBody, shedRoof);
            shed.position.set(12, 0, 5);
            scene.add(shed);
            
            // Fence
            const fenceMat = new THREE.MeshLambertMaterial({ color: 0x3d2b1f });
            for(let i = 0; i < 20; i++) {
                const post = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.5, 0.2), fenceMat);
                post.position.set(-15 + i * 2, 0.75, -10);
                scene.add(post);
                if (i < 19) {
                    const rail1 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.15, 0.15), fenceMat);
                    rail1.position.set(-14 + i * 2, 1, -10);
                    scene.add(rail1);
                    const rail2 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.15, 0.15), fenceMat);
                    rail2.position.set(-14 + i * 2, 0.5, -10);
                    scene.add(rail2);
                }
            }


            // Trees & Decorations
            const pineGeo = new THREE.ConeGeometry(1, 4, 8);
            const pineMat = new THREE.MeshLambertMaterial({ color: 0x2d5a27 });
            for (let i = 0; i < 50; i++) {
                const tree = new THREE.Mesh(pineGeo, pineMat);
                tree.position.set((Math.random() - 0.5) * 80, 2, (Math.random() - 0.5) * 80);
                if (Math.abs(tree.position.x) < 7 && tree.position.z > -10) continue; // Avoid water and fence
                tree.scale.setScalar(Math.random() * 0.5 + 0.8);
                scene.add(tree);
            }
             const autumnColors = [0xffa500, 0xff4500, 0xdaa520];
            const trunkMat = new THREE.MeshLambertMaterial({ color: 0x5c3d2e });
            for (let i = 0; i < 30; i++) {
                const foliageMat = new THREE.MeshLambertMaterial({ color: autumnColors[Math.floor(Math.random() * autumnColors.length)] });
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 5, 8), trunkMat);
                const foliage = new THREE.Mesh(new THREE.SphereGeometry(2.5, 8, 6), foliageMat);
                trunk.position.set((Math.random() - 0.5) * 80, 2.5, (Math.random() - 0.5) * 80);
                 if (Math.abs(trunk.position.x) < 7 && trunk.position.z > -10) continue;
                foliage.position.y = 5;
                trunk.add(foliage);
                scene.add(trunk);
            }

            const decGeo = new THREE.IcosahedronGeometry(0.5, 0);
            const decMats = [ new THREE.MeshStandardMaterial({color:0xff0000, emissive: 0x330000}), new THREE.MeshStandardMaterial({color:0x0000ff, emissive: 0x000033}), new THREE.MeshStandardMaterial({color:0x800080, emissive: 0x200020})];
            for(let i=0; i<30; i++) {
                const dec = new THREE.Mesh(decGeo, decMats[i % 3]);
                dec.position.set((Math.random() - 0.5) * 80, 0.5, (Math.random() - 0.5) * 80);
                scene.add(dec);
            }
        }

        function createWeapon() {
            weaponHolder = new THREE.Group();
            camera.add(weaponHolder);
            weaponHolder.position.set(0.5, -0.4, -0.8);
            weaponHolder.rotation.y = -0.1;

            const swordGeo = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                // Blade
                0, 0, 0, -0.05, 0, 1.5, 0.05, 0, 1.5,
                0, 0.05, 1.5, 0, 0, 0, 0, -0.05, 1.5,
                // Point
                -0.05, 0, 1.5, 0, 0, 1.8, 0.05, 0, 1.5,
                // Guard
                -0.2, 0, 0, 0.2, 0, 0, 0, -0.05, 0,
                0.2, 0, 0, -0.2, 0, 0, 0, 0.05, 0,
                // Hilt
                0, 0, -0.5, 0, 0, 0
            ]);
            swordGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            swordGeo.computeVertexNormals();

            const swordMat = new THREE.MeshStandardMaterial({
                color: 0xa8a8a8,
                metalness: 0.8,
                roughness: 0.4,
                emissive: 0xffa200,
                emissiveIntensity: 1.5
            });
            sword = new THREE.Mesh(swordGeo, swordMat);
            weaponHolder.add(sword);

            // Flame Particles
            const flameParticleCount = 50;
            const flamePositions = new Float32Array(flameParticleCount * 3);
            for (let i = 0; i < flameParticleCount; i++) {
                flamePositions[i*3 + 0] = (Math.random() - 0.5) * 0.1; // x spread
                flamePositions[i*3 + 1] = 0; // y start
                flamePositions[i*3 + 2] = Math.random() * 1.5; // z along blade
            }
            const flameGeo = new THREE.BufferGeometry();
            flameGeo.setAttribute('position', new THREE.BufferAttribute(flamePositions, 3));
            const flameMat = new THREE.PointsMaterial({
                color: 0xffa200,
                size: 0.08,
                transparent: true,
                blending: THREE.AdditiveBlending,
                opacity: 0.8,
                depthWrite: false
            });
            swordFlames = new THREE.Points(flameGeo, flameMat);
            sword.add(swordFlames);
        }

        function createWeather() {
            // Rain
            const rainCount = 10000;
            const rainGeo = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < rainCount; i++) {
                vertices.push(
                    Math.random() * 100 - 50,
                    Math.random() * 50,
                    Math.random() * 100 - 50
                );
            }
            rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const rainMat = new THREE.PointsMaterial({
                color: 0xaaaaaa,
                size: 0.1,
                transparent: true,
                opacity: 0.5
            });
            rain = new THREE.Points(rainGeo, rainMat);
            scene.add(rain);

            // Lightning
            lightningFlash = new THREE.PointLight(0xffffff, 0, 100);
            lightningFlash.position.set(0, 50, 0);
            scene.add(lightningFlash);
        }

        function spawnSpirits() {
            const spiritGeo = new THREE.SphereGeometry(0.8, 16, 16);
            for (let i = 0; i < TOTAL_SPIRITS; i++) {
                const spirit = new THREE.Group();
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0x3d0f5b,
                    transparent: true,
                    opacity: 0.8
                });
                const body = new THREE.Mesh(spiritGeo, bodyMat);
                
                const particleCount = 100;
                const particlesGeo = new THREE.BufferGeometry();
                const posArray = new Float32Array(particleCount * 3);
                for(let j=0; j<particleCount * 3; j++) {
                    posArray[j] = (Math.random() - 0.5) * 3;
                }
                particlesGeo.setAttribute('position', new THREE.Float32BufferAttribute(posArray, 3));
                const particleMat = new THREE.PointsMaterial({ size: 0.05, color: 0x8e44ad });
                const particles = new THREE.Points(particlesGeo, particleMat);
                
                spirit.add(body);
                spirit.add(particles);

                spirit.position.set((Math.random() - 0.5) * 70, 2, (Math.random() - 0.5) * 70);
                if (Math.abs(spirit.position.x) < 7) continue;

                spirit.userData = {
                    state: 'idle', // idle, chase
                    targetPosition: new THREE.Vector3().copy(spirit.position),
                    isCorrupted: true,
                    purifyTimer: 0
                };
                spirits.push(spirit);
                scene.add(spirit);
            }
        }
        
        function spawnWildlife() {
            // Bunnies
            const bunnyGeo = new THREE.CapsuleGeometry(0.1, 0.3, 4, 8);
            const bunnyMat = new THREE.MeshLambertMaterial({color: 0x967969});
            for(let i=0; i<10; i++) {
                const bunny = new THREE.Mesh(bunnyGeo, bunnyMat);
                bunny.position.set((Math.random() - 0.5) * 70, 0.25, (Math.random() - 0.5) * 70);
                bunny.userData = { type: 'bunny', state: 'idle', timer: Math.random() * 5 };
                wildlife.push(bunny);
                scene.add(bunny);
            }
            // Birds
            const birdGeo = new THREE.ConeGeometry(0.2, 0.5, 3);
            const birdMat = new THREE.MeshLambertMaterial({color: 0x444444});
            for(let i=0; i<5; i++) {
                const bird = new THREE.Mesh(birdGeo, birdMat);
                bird.position.set(0, 20 + Math.random() * 5, 0);
                bird.userData = { type: 'bird', angle: Math.random() * Math.PI * 2, radius: 20 + Math.random() * 10 };
                wildlife.push(bird);
                scene.add(bird);
            }
        }
        
        // --- Game Logic & Updates ---

        function fireProjectile() {
            const projectileGeo = new THREE.PlaneGeometry(3, 2); // A wide wave
            const projectileMat = new THREE.MeshBasicMaterial({
                color: 0xffa200,
                side: THREE.DoubleSide,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            projectileMat.onBeforeCompile = shader => {
                shader.vertexShader = 'varying vec2 vUv;\n' + shader.vertexShader;
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <begin_vertex>',
                    '#include <begin_vertex>\nvUv = uv;'
                );
                shader.fragmentShader = 'varying vec2 vUv;\n' + shader.fragmentShader;
                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <color_fragment>',
                    `
                     vec3 fireColor = outgoingLight;
                     float fadeX = 1.0 - pow(abs(vUv.x - 0.5) * 2.0, 2.0);
                     float fadeY = 1.0 - vUv.y;
                     float alpha = fadeX * fadeY;
                     gl_FragColor = vec4(fireColor, alpha);
                    `
                );
            };
            const projectile = new THREE.Mesh(projectileGeo, projectileMat);

            const forwardVector = new THREE.Vector3(0, 0, -1);
            forwardVector.applyQuaternion(camera.quaternion);

            projectile.position.copy(camera.position).add(forwardVector.clone().multiplyScalar(1.5));
            projectile.quaternion.copy(camera.quaternion);

            projectile.userData = {
                velocity: forwardVector.clone().normalize().multiplyScalar(40),
                lifetime: 7 / 40 // distance / speed
            };
            projectiles.push(projectile);
            scene.add(projectile);
        }

        function updateAtmosphere(delta) {
            const progress = Math.min(savedSpirits / SPIRITS_TO_WIN, 1.0);

            scene.background.lerpColors(atmosphere.start.sky, atmosphere.end.sky, progress);
            // Fog is disabled
            // scene.fog.color.lerpColors(atmosphere.start.fog, atmosphere.end.fog, progress);
            // scene.fog.near = THREE.MathUtils.lerp(atmosphere.fogNear.start, atmosphere.fogNear.end, progress);
            // scene.fog.far = THREE.MathUtils.lerp(atmosphere.fogFar.start, atmosphere.fogFar.end, progress);

            directionalLight.color.lerpColors(atmosphere.start.sun, atmosphere.end.sun, progress);
            directionalLight.intensity = THREE.MathUtils.lerp(atmosphere.sunIntensity.start, atmosphere.sunIntensity.end, progress);

            if (progress > 0.7) {
                const bloomProgress = (progress - 0.7) / 0.3;
                bloomPass.strength = THREE.MathUtils.lerp(atmosphere.bloomStrength.start, atmosphere.bloomStrength.end, bloomProgress);
            }

            // Weather effects fade out
            rain.material.opacity = Math.max(0, 0.5 - progress);
            if (progress >= 1.0) {
                if(rain) scene.remove(rain);
                rain = null;
            } else {
                time += delta;
                if (Math.random() < 0.002) { // Random lightning
                    lightningFlash.intensity = 20 * (1.0-progress);
                    lightningFlash.power = 500 * (1.0-progress);
                }
                lightningFlash.intensity = Math.max(0, lightningFlash.intensity - 150 * delta);
                lightningFlash.power = Math.max(0, lightningFlash.power - 3000 * delta);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // Player Update
            if (controls.isLocked) {
                const speed = player.speed * (player.onGround ? 1 : 0.4); // Air control
                player.velocity.x -= player.velocity.x * 10.0 * delta;
                player.velocity.z -= player.velocity.z * 10.0 * delta;
                player.velocity.y -= player.gravity * delta;

                player.direction.z = Number(moveForward.value) - Number(moveBackward.value);
                player.direction.x = Number(moveRight.value) - Number(moveLeft.value);
                player.direction.normalize();

                if (moveForward.value || moveBackward.value) player.velocity.z -= player.direction.z * speed * delta;
                if (moveLeft.value || moveRight.value) player.velocity.x -= player.direction.x * speed * delta;
                
                controls.moveRight(-player.velocity.x * delta);
                controls.moveForward(-player.velocity.z * delta);
                controls.getObject().position.y += (player.velocity.y * delta);

                if (controls.getObject().position.y < player.height) {
                    player.velocity.y = 0;
                    controls.getObject().position.y = player.height;
                    player.onGround = true;
                } else {
                    player.onGround = false;
                }
            }
            
            // Weapon Update
            if (isSwinging) {
                swingProgress = Math.min(swingProgress + delta * 4, 1.0); // Swing lasts 0.25s
                const swingAngle = Math.sin(swingProgress * Math.PI) * -1.5;
                const swingOffset = Math.sin(swingProgress * Math.PI) * -0.5;

                weaponHolder.rotation.x = swingAngle;
                weaponHolder.position.z = -0.8 + swingOffset;

                if (swingProgress >= 1) {
                    isSwinging = false;
                }
            } else {
                 weaponHolder.rotation.x *= 0.8; // Smoothly return to base rotation
                 weaponHolder.position.lerp(new THREE.Vector3(0.5, -0.4, -0.8), delta * 10);
            }

            // Sword flame particle animation
            if (swordFlames) {
                const positions = swordFlames.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] += delta * 3; // Move up
                    if (positions[i + 1] > 1.0) {
                        positions[i + 1] = Math.random() * 0.1; // Reset to bottom with slight variance
                    }
                }
                swordFlames.geometry.attributes.position.needsUpdate = true;
            }


            // Projectiles Update
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.position.add(p.userData.velocity.clone().multiplyScalar(delta));
                p.userData.lifetime -= delta;
                if (p.userData.lifetime <= 0) {
                    scene.remove(p);
                    projectiles.splice(i, 1);
                }
            }

            // Spirits Update
            const playerPos = controls.getObject().position;
            for (const spirit of spirits) {
                if (!spirit.userData.isCorrupted) {
                    spirit.userData.purifyTimer -= delta;
                    spirit.position.y += delta * 2;
                    spirit.children[0].material.opacity = Math.max(0, spirit.userData.purifyTimer);
                    if(spirit.children[1]) spirit.children[1].material.opacity = Math.max(0, spirit.userData.purifyTimer);
                    if (spirit.userData.purifyTimer <= 0) {
                        scene.remove(spirit);
                    }
                    continue;
                }
                
                spirit.children[1].rotation.x += delta * 0.5;
                spirit.children[1].rotation.y += delta * 0.7;

                const distToPlayer = spirit.position.distanceTo(playerPos);
                if (distToPlayer < 15) {
                    spirit.userData.state = 'chase';
                } else if (distToPlayer > 20) {
                    spirit.userData.state = 'idle';
                }
                
                if (spirit.userData.state === 'chase') {
                   spirit.position.lerp(playerPos, delta * 0.3);
                   spirit.position.y = 2;
                } else { // idle
                    if(spirit.position.distanceTo(spirit.userData.targetPosition) < 1) {
                        spirit.userData.targetPosition.set(
                            spirit.position.x + (Math.random() - 0.5) * 10,
                            2,
                            spirit.position.z + (Math.random() - 0.5) * 10
                        );
                    }
                     spirit.position.lerp(spirit.userData.targetPosition, delta * 0.1);
                }
                
                // Collision
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    if (p.position.distanceTo(spirit.position) < 2.0) { // Increased collision radius
                        purifySpirit(spirit);
                        scene.remove(p);
                        projectiles.splice(i, 1);
                        break;
                    }
                }
            }
            
            // Wildlife update
            for(const animal of wildlife) {
                const distToPlayer = animal.position.distanceTo(playerPos);
                if(distToPlayer < 10 && animal.userData.type !== 'bird') {
                    const fleeDir = new THREE.Vector3().subVectors(animal.position, playerPos).normalize();
                    animal.position.add(fleeDir.multiplyScalar(delta * 5));
                } else if (animal.userData.type === 'bunny') {
                    animal.userData.timer -= delta;
                    if(animal.userData.timer < 0) {
                        animal.position.y = 0.5 + Math.sin(animal.userData.timer * 20) * 0.2;
                        if(animal.userData.timer < -0.5) {
                           animal.userData.timer = Math.random() * 5 + 2;
                           animal.position.y = 0.25;
                        }
                    }
                } else if(animal.userData.type === 'bird') {
                    animal.userData.angle += delta * 0.5;
                    animal.position.x = Math.cos(animal.userData.angle) * animal.userData.radius;
                    animal.position.z = Math.sin(animal.userData.angle) * animal.userData.radius;
                    animal.lookAt(0, animal.position.y, 0);
                }
            }


            // Weather update
            if (rain) {
                const positions = rain.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] -= 30 * delta;
                    if (positions[i + 1] < 0) {
                        positions[i + 1] = 50;
                    }
                }
                rain.geometry.attributes.position.needsUpdate = true;
            }

            updateAtmosphere(delta);
            composer.render(delta);
        }

        function purifySpirit(spirit) {
            if (!spirit.userData.isCorrupted) return;

            spirit.userData.isCorrupted = false;
            spirit.userData.purifyTimer = 2.0;
            
            spirit.children[0].material.color.set(0xfffacd);
            spirit.children[0].material.emissive.set(0xffffff);
            spirit.children[0].material.emissiveIntensity = 2;
            
            if (spirit.children[1]) scene.remove(spirit.children[1]);

            if (savedSpirits < SPIRITS_TO_WIN) {
                savedSpirits++;
                document.getElementById('score').innerText = `Spirits Saved: ${savedSpirits}/${SPIRITS_TO_WIN}`;
                if (savedSpirits === SPIRITS_TO_WIN) {
                    document.getElementById('win').style.display = 'block';
                }
            }
        }

    </script>
</body>
</html>
