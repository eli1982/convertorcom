
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Mystic Forest Farm</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #instructions {
            width: 50%;
            text-align: center;
            cursor: pointer;
            padding: 20px;
            border: 2px solid white;
            border-radius: 10px;
        }
        #instructions h1 {
            font-size: 2.5rem;
            margin-top: 0;
        }
        #instructions p {
            font-size: 1.2rem;
        }
        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000000;
            pointer-events: none;
            z-index: 10;
        }
        #win-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 5rem;
            font-weight: bold;
            color: #00ff00;
            text-shadow: 3px 3px 6px #000;
            display: none;
            pointer-events: none;
            z-index: 11;
        }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>Mystic Forest Farm</h1>
            <p>The forest is corrupted. Use your magic staff to cleanse the spirits.</p>
            <p>WASD: Move | SPACE: Jump | MOUSE: Look</p>
            <p>HOLD LEFT MOUSE to charge, RELEASE to fire.</p>
            <p>Cleanse 10 spirits to restore peace.</p>
            <br>
            <strong>Click to Begin</strong>
        </div>
    </div>
    <div id="ui">Spirits Saved: 0/10</div>
    <div id="win-message">FOREST RESTORED</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { Reflector } from 'three/addons/objects/Reflector.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let camera, scene, renderer, controls, composer, bloomPass;
        let world, clock;
        let playerVelocity = new THREE.Vector3();
        let playerDirection = new THREE.Vector3();
        let onObject = false;

        const player = {
            height: 2.0,
            speed: 40.0,
            gravity: 9.8 * 0.7, // Floaty gravity
            jumpHeight: 8.0,
            canJump: true,
            isMoving: false,
        };

        const keyStates = {};
        const projectiles = [];
        const spirits = [];
        const TOTAL_SPIRITS_TO_SAVE = 10;
        const ACTIVE_SPIRITS_COUNT = 15;
        let spiritsSaved = 0;
        
        let staff, staffGem;
        let chargeTime = 0;
        let isCharging = false;

        const atmosphere = {
            skyColorStart: new THREE.Color(0x1a1a2e),
            skyColorEnd: new THREE.Color(0x87CEEB),
            fogColorStart: new THREE.Color(0x1a1a2e),
            fogColorEnd: new THREE.Color(0xFFFFFF),
            lightColorStart: new THREE.Color(0xffffff),
            lightColorEnd: new THREE.Color(0xFFFACD),
            sunIntensityStart: 0.5,
            sunIntensityEnd: 1.5,
            fogNearStart: 5,
            fogFarStart: 25,
            fogNearEnd: 200,
            fogFarEnd: 500,
            bloomStrengthStart: 0.6,
            bloomStrengthEnd: 0.0,
        };
        let ambientLight, sunLight;
        let rain, thunderTimer;
        
        const uiElement = document.getElementById('ui');
        const winMessageElement = document.getElementById('win-message');
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');

        init();
        animate();

        function init() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = player.height;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(atmosphere.skyColorStart);
            document.body.appendChild(renderer.domElement);

            // Fog
            scene.fog = new THREE.Fog(atmosphere.fogColorStart, atmosphere.fogNearStart, atmosphere.fogFarStart);
            scene.background = atmosphere.skyColorStart;

            // Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(atmosphere.lightColorStart, atmosphere.sunIntensityStart);
            sunLight.position.set(50, 50, 50);
            sunLight.castShadow = true;
            scene.add(sunLight);

            // Post-processing
            const renderPass = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = atmosphere.bloomStrengthStart;
            bloomPass.radius = 0;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            // Pointer Lock Controls
            controls = new PointerLockControls(camera, renderer.domElement);
            instructions.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
            });
            controls.addEventListener('unlock', () => {
                blocker.style.display = 'flex';
                instructions.style.display = '';
            });
            scene.add(controls.getObject());

            // Event Listeners
            document.addEventListener('keydown', (event) => { keyStates[event.code] = true; });
            document.addEventListener('keyup', (event) => { keyStates[event.code] = false; });
            document.addEventListener('mousedown', (event) => { if(event.button === 0 && controls.isLocked) isCharging = true; });
            document.addEventListener('mouseup', (event) => {
                if (event.button === 0 && controls.isLocked) {
                    isCharging = false;
                    fireProjectile();
                }
            });
            window.addEventListener('resize', onWindowResize);

            createEnvironment();
            createWeapon();
            createSpirits();
            createWeather();
            updateAtmosphere();
        }

        function createProceduralTexture(size, color1, color2) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            const imageData = context.createImageData(size, size);
            const data = imageData.data;
            const c1 = new THREE.Color(color1);
            const c2 = new THREE.Color(color2);

            for (let i = 0; i < data.length; i += 4) {
                const color = Math.random() > 0.5 ? c1 : c2;
                data[i] = color.r * 255;
                data[i + 1] = color.g * 255;
                data[i + 2] = color.b * 255;
                data[i + 3] = 255;
            }
            context.putImageData(imageData, 0, 0);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 10);
            return texture;
        }

        function createEnvironment() {
            // Ground
            const groundGeo = new THREE.PlaneGeometry(80, 80);
            const groundMat = new THREE.MeshLambertMaterial({ color: 0x4a7d2c }); // Greenish ground inspired by image
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            // Water
            const waterGeo = new THREE.PlaneGeometry(10, 80);
            const water = new Reflector(waterGeo, {
                clipBias: 0.003,
                textureWidth: window.innerWidth * window.devicePixelRatio,
                textureHeight: window.innerHeight * window.devicePixelRatio,
                color: 0x777777,
            });
            water.rotation.x = -Math.PI / 2;
            water.position.y = 0.01;
            scene.add(water);

            // Structure (Farmhouse/Church inspired)
            const wallTexture = createProceduralTexture(64, 0xcccccc, 0xbbbbbb);
            const buildingMat = new THREE.MeshLambertMaterial({ map: wallTexture });
            const mainBuilding = new THREE.Mesh(new THREE.BoxGeometry(8, 6, 12), buildingMat);
            mainBuilding.position.set(20, 3, 0);
            scene.add(mainBuilding);

            const roofTexture = createProceduralTexture(32, 0x8B4513, 0xA0522D);
            const roofMat = new THREE.MeshLambertMaterial({ map: roofTexture });
            const roof = new THREE.Mesh(new THREE.ConeGeometry(7, 4, 4), roofMat);
            roof.position.set(20, 6 + 2, 0);
            roof.rotation.y = Math.PI / 4;
            scene.add(roof);

            // Trees
            const treeMat = new THREE.MeshLambertMaterial({ color: 0x2d5a27 });
            for (let i = 0; i < 50; i++) {
                const height = Math.random() * 10 + 5;
                const tree = new THREE.Mesh(new THREE.ConeGeometry(2, height, 8), treeMat);
                tree.position.set(
                    (Math.random() - 0.5) * 75,
                    height / 2,
                    (Math.random() - 0.5) * 75
                );
                if (Math.abs(tree.position.x) < 8 && Math.abs(tree.position.z) < 8) continue; // Avoid water
                scene.add(tree);
            }
            
            // Decorations
            const decorationColors = [0xff0000, 0x0000ff, 0x800080];
            for (let i = 0; i < 20; i++) {
                const geo = Math.random() > 0.5 ? new THREE.BoxGeometry(0.5,0.5,0.5) : new THREE.SphereGeometry(0.3, 8, 8);
                const mat = new THREE.MeshLambertMaterial({color: decorationColors[Math.floor(Math.random()*3)]});
                const deco = new THREE.Mesh(geo, mat);
                deco.position.set(
                    (Math.random() - 0.5) * 75,
                    0.25,
                    (Math.random() - 0.5) * 75
                );
                scene.add(deco);
            }
        }
        
        function createWeapon() {
            const staffGroup = new THREE.Group();
            const staffMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
            const staffCylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1, 8), staffMat);
            
            const gemMat = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0,
                transparent: true,
                opacity: 0.8,
            });
            staffGem = new THREE.Mesh(new THREE.IcosahedronGeometry(0.1, 0), gemMat);
            staffGem.position.y = 0.55;

            staffGroup.add(staffCylinder);
            staffGroup.add(staffGem);
            staffGroup.position.set(0.4, -0.4, -0.7);
            staffGroup.rotation.x = -0.2;
            staffGroup.rotation.y = -0.3;

            staff = staffGroup;
            camera.add(staff);
        }

        function createSpirits() {
            const spiritGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const spiritColors = [0x880088, 0xaa0000, 0x444444];
            
            for (let i = 0; i < ACTIVE_SPIRITS_COUNT; i++) {
                const color = spiritColors[i % 3];
                const mat = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.5
                });
                const spirit = new THREE.Mesh(spiritGeo, mat);
                
                spirit.state = 'idle';
                spirit.targetPosition = new THREE.Vector3();
                spirit.speed = 3.0;
                
                respawnSpirit(spirit);
                spirits.push(spirit);
                scene.add(spirit);
            }
        }

        function respawnSpirit(spirit) {
            spirit.position.set(
                (Math.random() - 0.5) * 70,
                Math.random() * 3 + 1,
                (Math.random() - 0.5) * 70
            );
            spirit.targetPosition.copy(spirit.position);
            spirit.cleansed = false;
        }

        function createWeather() {
            const rainCount = 10000;
            const positions = [];
            for (let i = 0; i < rainCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * 80,
                    Math.random() * 50,
                    (Math.random() - 0.5) * 80
                );
            }
            const rainGeo = new THREE.BufferGeometry();
            rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const rainMat = new THREE.PointsMaterial({
                color: 0xaaaaaa,
                size: 0.1,
                transparent: true,
                opacity: 0.7
            });
            
            rain = new THREE.Points(rainGeo, rainMat);
            scene.add(rain);

            thunderTimer = setInterval(triggerThunder, 15000);
        }
        
        function triggerThunder() {
            if (spiritsSaved / TOTAL_SPIRITS_TO_SAVE > 0.8) return;
            const originalIntensity = sunLight.intensity;
            const originalAmbient = ambientLight.intensity;
            sunLight.intensity = 2.0;
            ambientLight.intensity = 1.0;
            setTimeout(() => {
                sunLight.intensity = 0.5;
                ambientLight.intensity = 0.2;
                setTimeout(() => {
                    updateAtmosphere(); // Restore to current lerped value
                }, 150);
            }, 100);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function handlePlayerControls(delta) {
            if (!controls.isLocked) return;

            const speed = player.speed;
            const moveSpeed = speed * delta;
            player.isMoving = false;

            if (keyStates['KeyW'] || keyStates['ArrowUp']) {
                controls.moveForward(moveSpeed);
                player.isMoving = true;
            }
            if (keyStates['KeyS'] || keyStates['ArrowDown']) {
                controls.moveForward(-moveSpeed);
                player.isMoving = true;
            }
            if (keyStates['KeyA'] || keyStates['ArrowLeft']) {
                controls.moveRight(-moveSpeed);
                player.isMoving = true;
            }
            if (keyStates['KeyD'] || keyStates['ArrowRight']) {
                controls.moveRight(moveSpeed);
                player.isMoving = true;
            }
            if (keyStates['Space'] && player.canJump) {
                playerVelocity.y += player.jumpHeight;
                player.canJump = false;
            }
        }

        function updatePlayer(delta) {
            if (!controls.isLocked) return;
            
            let pos = controls.getObject().position;

            playerVelocity.y -= player.gravity * delta;
            pos.y += playerVelocity.y * delta;
            
            if (pos.y < player.height) {
                pos.y = player.height;
                playerVelocity.y = 0;
                player.canJump = true;
            }

            // Simple world boundary
            pos.x = Math.max(-39, Math.min(39, pos.x));
            pos.z = Math.max(-39, Math.min(39, pos.z));
        }

        function updateSpirits(delta) {
            const playerPos = controls.getObject().position;
            spirits.forEach(spirit => {
                if (spirit.cleansed) return;

                const distanceToPlayer = spirit.position.distanceTo(playerPos);
                
                if (distanceToPlayer < 10) {
                    spirit.state = 'chase';
                    spirit.targetPosition.copy(playerPos);
                } else if (spirit.state === 'chase' || spirit.position.distanceTo(spirit.targetPosition) < 1) {
                    spirit.state = 'idle';
                    spirit.targetPosition.set(
                        (Math.random() - 0.5) * 70,
                        Math.random() * 3 + 1,
                        (Math.random() - 0.5) * 70
                    );
                }

                const direction = new THREE.Vector3().subVectors(spirit.targetPosition, spirit.position).normalize();
                spirit.position.add(direction.multiplyScalar(spirit.speed * delta));
                spirit.position.y = Math.max(0.5, spirit.position.y);
            });
        }
        
        function fireProjectile() {
            if (chargeTime < 0.1) return; // Must charge at least a bit

            const projectileGeo = new THREE.IcosahedronGeometry(0.1 + chargeTime * 0.1, 0);
            const projectileMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const projectile = new THREE.Mesh(projectileGeo, projectileMat);

            camera.getWorldDirection(playerDirection);
            projectile.position.copy(controls.getObject().position).add(playerDirection.multiplyScalar(1.5));
            projectile.velocity = new THREE.Vector3().copy(playerDirection).multiplyScalar(50);
            projectile.lifetime = 2.0;
            
            projectiles.push(projectile);
            scene.add(projectile);
            
            chargeTime = 0;
        }

        function updateProjectiles(delta) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.position.add(p.velocity.clone().multiplyScalar(delta));
                p.lifetime -= delta;

                if (p.lifetime <= 0) {
                    scene.remove(p);
                    projectiles.splice(i, 1);
                    continue;
                }

                // Collision check
                for (let j = 0; j < spirits.length; j++) {
                    const spirit = spirits[j];
                    if (spirit.cleansed) continue;
                    
                    if (p.position.distanceTo(spirit.position) < 0.6) { // 0.1 projectile radius + 0.5 spirit radius
                        cleanseSpirit(spirit);
                        scene.remove(p);
                        projectiles.splice(i, 1);
                        break; 
                    }
                }
            }
        }
        
        function cleanseSpirit(spirit) {
            spirit.cleansed = true;
            
            // "Purify" effect
            spirit.material.emissive.set(0xffffff);
            spirit.material.color.set(0x87CEEB);

            const upwardMovement = setInterval(() => {
                spirit.position.y += 0.1;
                spirit.material.opacity -= 0.05;
                if(spirit.material.opacity <= 0) {
                    clearInterval(upwardMovement);
                    respawnSpirit(spirit);
                }
            }, 50);

            if (spiritsSaved < TOTAL_SPIRITS_TO_SAVE) {
                spiritsSaved++;
                updateUI();
                updateAtmosphere();
            }
        }

        function updateUI() {
            uiElement.textContent = `Spirits Saved: ${spiritsSaved}/${TOTAL_SPIRITS_TO_SAVE}`;
            if (spiritsSaved >= TOTAL_SPIRITS_TO_SAVE) {
                winMessageElement.style.display = 'block';
                uiElement.style.display = 'none';
                if(controls.isLocked) controls.unlock();
            }
        }

        function updateAtmosphere() {
            const progress = spiritsSaved / TOTAL_SPIRITS_TO_SAVE;
            
            const skyColor = new THREE.Color().copy(atmosphere.skyColorStart).lerp(atmosphere.skyColorEnd, progress);
            scene.background = skyColor;
            
            const fogColor = new THREE.Color().copy(atmosphere.fogColorStart).lerp(atmosphere.fogColorEnd, progress);
            scene.fog.color = fogColor;
            
            scene.fog.near = THREE.MathUtils.lerp(atmosphere.fogNearStart, atmosphere.fogNearEnd, progress);
            scene.fog.far = THREE.MathUtils.lerp(atmosphere.fogFarStart, atmosphere.fogFarEnd, progress);
            
            sunLight.color.copy(atmosphere.lightColorStart).lerp(atmosphere.lightColorEnd, progress);
            sunLight.intensity = THREE.MathUtils.lerp(atmosphere.sunIntensityStart, atmosphere.sunIntensityEnd, progress);
            
            if (progress < 0.7) {
                bloomPass.strength = THREE.MathUtils.lerp(atmosphere.bloomStrengthStart, atmosphere.bloomStrengthEnd, progress / 0.7);
            } else {
                bloomPass.strength = 0;
            }

            if (rain) {
                rain.material.opacity = Math.max(0, 1.0 - progress * 1.5);
            }
            if (progress > 0.9) {
                clearInterval(thunderTimer);
            }
        }

        function updateWeapon(delta) {
            // Charging effect
            if (isCharging) {
                chargeTime = Math.min(1.0, chargeTime + delta * 1.5);
                staffGem.material.emissiveIntensity = chargeTime * 5;
                
                // Shake effect
                const shakeIntensity = chargeTime * 0.01;
                staff.position.x = 0.4 + (Math.random() - 0.5) * shakeIntensity;
                staff.position.y = -0.4 + (Math.random() - 0.5) * shakeIntensity;
            } else {
                staffGem.material.emissiveIntensity = THREE.MathUtils.lerp(staffGem.material.emissiveIntensity, 0, delta * 10);
                staff.position.lerp(new THREE.Vector3(0.4, -0.4, -0.7), delta * 10);
            }

            // Bobbing effect
            if(player.isMoving && player.canJump) { // only bob when on ground
                const bobTime = clock.getElapsedTime() * 10;
                staff.position.y += Math.sin(bobTime) * 0.01;
                staff.position.x += Math.cos(bobTime * 0.5) * 0.01;
            }
        }

        function updateWeather(delta) {
            if (!rain || rain.material.opacity <= 0) return;
            const positions = rain.geometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] -= 30 * delta; // Rain speed
                if (positions[i] < 0) {
                    positions[i] = 50;
                }
            }
            rain.geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = Math.min(clock.getDelta(), 0.1);

            handlePlayerControls(delta);
            updatePlayer(delta);
            updateSpirits(delta);
            updateProjectiles(delta);
            updateWeapon(delta);
            updateWeather(delta);
            
            composer.render();
        }

    </script>
</body>
</html>
